{"version":3,"sources":["webpack:///promise-polyfill.js","webpack:///webpack/bootstrap 5f646175bd23ce24c0b6","webpack:///./lib/src/promise-polyfill/index.js","webpack:///./~/es6-promise-polyfill/promise.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/process/browser.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","window","Promise","polyfill","__WEBPACK_AMD_DEFINE_RESULT__","global","setImmediate","_typeof","Symbol","iterator","obj","constructor","isArray","value","Object","prototype","toString","asyncFlush","i","asyncQueue","length","asyncTimer","asyncCall","callback","arg","push","asyncSetTimer","invokeResolver","resolver","promise","resolvePromise","resolve","rejectPromise","reason","reject","e","invokeCallback","subscriber","owner","settled","state_","data_","then","FULFILLED","handleThenable","REJECTED","resolved","TypeError","val","fulfill","PENDING","SEALED","publishFulfillment","publishRejection","publish","callbacks","then_","undefined","this","NativePromise","nativePromiseSupported","r","Polyfill","NOOP","setTimeout","onFulfillment","onRejection","fulfilled","rejected","catch","all","promises","Class","index","remaining","results","race","self","clearImmediate","Timeout","clearFn","_id","_clearFn","nextTick","apply","Function","slice","Array","immediateIds","nextImmediateId","arguments","clearTimeout","setInterval","clearInterval","timeout","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","fn","args","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","len","run","Item","array","noop","process","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask"],"mappings":"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","file":"promise-polyfill.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tif (!window.Promise) {\n\t    var polyfill = __webpack_require__(1);\n\t    if (polyfill && polyfill.Promise) {\n\t        window.Promise = polyfill.Promise;\n\t    }\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate) {'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t(function (global) {\n\t\n\t  //\n\t  // Check for native Promise and it has correct interface\n\t  //\n\t\n\t  var NativePromise = global['Promise'];\n\t  var nativePromiseSupported = NativePromise &&\n\t  // Some of these methods are missing from\n\t  // Firefox/Chrome experimental implementations\n\t  'resolve' in NativePromise && 'reject' in NativePromise && 'all' in NativePromise && 'race' in NativePromise &&\n\t  // Older version of the spec had a resolver object\n\t  // as the arg rather than a function\n\t  function () {\n\t    var resolve;\n\t    new NativePromise(function (r) {\n\t      resolve = r;\n\t    });\n\t    return typeof resolve === 'function';\n\t  }();\n\t\n\t  //\n\t  // export if necessary\n\t  //\n\t\n\t  if (typeof exports !== 'undefined' && exports) {\n\t    // node.js\n\t    exports.Promise = nativePromiseSupported ? NativePromise : Promise;\n\t    exports.Polyfill = Promise;\n\t  } else {\n\t    // AMD\n\t    if (true) {\n\t      !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t        return nativePromiseSupported ? NativePromise : Promise;\n\t      }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else {\n\t      // in browser add to global\n\t      if (!nativePromiseSupported) global['Promise'] = Promise;\n\t    }\n\t  }\n\t\n\t  //\n\t  // Polyfill\n\t  //\n\t\n\t  var PENDING = 'pending';\n\t  var SEALED = 'sealed';\n\t  var FULFILLED = 'fulfilled';\n\t  var REJECTED = 'rejected';\n\t  var NOOP = function NOOP() {};\n\t\n\t  function isArray(value) {\n\t    return Object.prototype.toString.call(value) === '[object Array]';\n\t  }\n\t\n\t  // async calls\n\t  var asyncSetTimer = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;\n\t  var asyncQueue = [];\n\t  var asyncTimer;\n\t\n\t  function asyncFlush() {\n\t    // run promise callbacks\n\t    for (var i = 0; i < asyncQueue.length; i++) {\n\t      asyncQueue[i][0](asyncQueue[i][1]);\n\t    } // reset async asyncQueue\n\t    asyncQueue = [];\n\t    asyncTimer = false;\n\t  }\n\t\n\t  function asyncCall(callback, arg) {\n\t    asyncQueue.push([callback, arg]);\n\t\n\t    if (!asyncTimer) {\n\t      asyncTimer = true;\n\t      asyncSetTimer(asyncFlush, 0);\n\t    }\n\t  }\n\t\n\t  function invokeResolver(resolver, promise) {\n\t    function resolvePromise(value) {\n\t      resolve(promise, value);\n\t    }\n\t\n\t    function rejectPromise(reason) {\n\t      reject(promise, reason);\n\t    }\n\t\n\t    try {\n\t      resolver(resolvePromise, rejectPromise);\n\t    } catch (e) {\n\t      rejectPromise(e);\n\t    }\n\t  }\n\t\n\t  function invokeCallback(subscriber) {\n\t    var owner = subscriber.owner;\n\t    var settled = owner.state_;\n\t    var value = owner.data_;\n\t    var callback = subscriber[settled];\n\t    var promise = subscriber.then;\n\t\n\t    if (typeof callback === 'function') {\n\t      settled = FULFILLED;\n\t      try {\n\t        value = callback(value);\n\t      } catch (e) {\n\t        reject(promise, e);\n\t      }\n\t    }\n\t\n\t    if (!handleThenable(promise, value)) {\n\t      if (settled === FULFILLED) resolve(promise, value);\n\t\n\t      if (settled === REJECTED) reject(promise, value);\n\t    }\n\t  }\n\t\n\t  function handleThenable(promise, value) {\n\t    var resolved;\n\t\n\t    try {\n\t      if (promise === value) throw new TypeError('A promises callback cannot return that same promise.');\n\t\n\t      if (value && (typeof value === 'function' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object')) {\n\t        var then = value.then; // then should be retrived only once\n\t\n\t        if (typeof then === 'function') {\n\t          then.call(value, function (val) {\n\t            if (!resolved) {\n\t              resolved = true;\n\t\n\t              if (value !== val) resolve(promise, val);else fulfill(promise, val);\n\t            }\n\t          }, function (reason) {\n\t            if (!resolved) {\n\t              resolved = true;\n\t\n\t              reject(promise, reason);\n\t            }\n\t          });\n\t\n\t          return true;\n\t        }\n\t      }\n\t    } catch (e) {\n\t      if (!resolved) reject(promise, e);\n\t\n\t      return true;\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function resolve(promise, value) {\n\t    if (promise === value || !handleThenable(promise, value)) fulfill(promise, value);\n\t  }\n\t\n\t  function fulfill(promise, value) {\n\t    if (promise.state_ === PENDING) {\n\t      promise.state_ = SEALED;\n\t      promise.data_ = value;\n\t\n\t      asyncCall(publishFulfillment, promise);\n\t    }\n\t  }\n\t\n\t  function reject(promise, reason) {\n\t    if (promise.state_ === PENDING) {\n\t      promise.state_ = SEALED;\n\t      promise.data_ = reason;\n\t\n\t      asyncCall(publishRejection, promise);\n\t    }\n\t  }\n\t\n\t  function publish(promise) {\n\t    var callbacks = promise.then_;\n\t    promise.then_ = undefined;\n\t\n\t    for (var i = 0; i < callbacks.length; i++) {\n\t      invokeCallback(callbacks[i]);\n\t    }\n\t  }\n\t\n\t  function publishFulfillment(promise) {\n\t    promise.state_ = FULFILLED;\n\t    publish(promise);\n\t  }\n\t\n\t  function publishRejection(promise) {\n\t    promise.state_ = REJECTED;\n\t    publish(promise);\n\t  }\n\t\n\t  /**\n\t  * @class\n\t  */\n\t  function Promise(resolver) {\n\t    if (typeof resolver !== 'function') throw new TypeError('Promise constructor takes a function argument');\n\t\n\t    if (this instanceof Promise === false) throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.');\n\t\n\t    this.then_ = [];\n\t\n\t    invokeResolver(resolver, this);\n\t  }\n\t\n\t  Promise.prototype = {\n\t    constructor: Promise,\n\t\n\t    state_: PENDING,\n\t    then_: null,\n\t    data_: undefined,\n\t\n\t    then: function then(onFulfillment, onRejection) {\n\t      var subscriber = {\n\t        owner: this,\n\t        then: new this.constructor(NOOP),\n\t        fulfilled: onFulfillment,\n\t        rejected: onRejection\n\t      };\n\t\n\t      if (this.state_ === FULFILLED || this.state_ === REJECTED) {\n\t        // already resolved, call callback async\n\t        asyncCall(invokeCallback, subscriber);\n\t      } else {\n\t        // subscribe\n\t        this.then_.push(subscriber);\n\t      }\n\t\n\t      return subscriber.then;\n\t    },\n\t\n\t    'catch': function _catch(onRejection) {\n\t      return this.then(null, onRejection);\n\t    }\n\t  };\n\t\n\t  Promise.all = function (promises) {\n\t    var Class = this;\n\t\n\t    if (!isArray(promises)) throw new TypeError('You must pass an array to Promise.all().');\n\t\n\t    return new Class(function (resolve, reject) {\n\t      var results = [];\n\t      var remaining = 0;\n\t\n\t      function resolver(index) {\n\t        remaining++;\n\t        return function (value) {\n\t          results[index] = value;\n\t          if (! --remaining) resolve(results);\n\t        };\n\t      }\n\t\n\t      for (var i = 0, promise; i < promises.length; i++) {\n\t        promise = promises[i];\n\t\n\t        if (promise && typeof promise.then === 'function') promise.then(resolver(i), reject);else results[i] = promise;\n\t      }\n\t\n\t      if (!remaining) resolve(results);\n\t    });\n\t  };\n\t\n\t  Promise.race = function (promises) {\n\t    var Class = this;\n\t\n\t    if (!isArray(promises)) throw new TypeError('You must pass an array to Promise.race().');\n\t\n\t    return new Class(function (resolve, reject) {\n\t      for (var i = 0, promise; i < promises.length; i++) {\n\t        promise = promises[i];\n\t\n\t        if (promise && typeof promise.then === 'function') promise.then(resolve, reject);else resolve(promise);\n\t      }\n\t    });\n\t  };\n\t\n\t  Promise.resolve = function (value) {\n\t    var Class = this;\n\t\n\t    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Class) return value;\n\t\n\t    return new Class(function (resolve) {\n\t      resolve(value);\n\t    });\n\t  };\n\t\n\t  Promise.reject = function (reason) {\n\t    var Class = this;\n\t\n\t    return new Class(function (resolve, reject) {\n\t      reject(reason);\n\t    });\n\t  };\n\t})(typeof window != 'undefined' ? window : typeof global != 'undefined' ? global : typeof self != 'undefined' ? self : undefined);\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2).setImmediate))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {\"use strict\";\n\t\n\tvar nextTick = __webpack_require__(3).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function () {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function () {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout = exports.clearInterval = function (timeout) {\n\t  timeout.close();\n\t};\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function () {};\n\tTimeout.prototype.close = function () {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function (item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function (item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function (item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout) item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function (fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function (id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).setImmediate, __webpack_require__(2).clearImmediate))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout() {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t})();\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch (e) {\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch (e) {\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e) {\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e) {\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while (len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () {\n\t    return '/';\n\t};\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function () {\n\t    return 0;\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** promise-polyfill.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5f646175bd23ce24c0b6\n **/","if (!window.Promise){\r\n    var polyfill = require('es6-promise-polyfill');\r\n    if (polyfill && polyfill.Promise){\r\n        window.Promise = polyfill.Promise;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/src/promise-polyfill/index.js\n **/","(function(global){\n\n//\n// Check for native Promise and it has correct interface\n//\n\nvar NativePromise = global['Promise'];\nvar nativePromiseSupported =\n  NativePromise &&\n  // Some of these methods are missing from\n  // Firefox/Chrome experimental implementations\n  'resolve' in NativePromise &&\n  'reject' in NativePromise &&\n  'all' in NativePromise &&\n  'race' in NativePromise &&\n  // Older version of the spec had a resolver object\n  // as the arg rather than a function\n  (function(){\n    var resolve;\n    new NativePromise(function(r){ resolve = r; });\n    return typeof resolve === 'function';\n  })();\n\n\n//\n// export if necessary\n//\n\nif (typeof exports !== 'undefined' && exports)\n{\n  // node.js\n  exports.Promise = nativePromiseSupported ? NativePromise : Promise;\n  exports.Polyfill = Promise;\n}\nelse\n{\n  // AMD\n  if (typeof define == 'function' && define.amd)\n  {\n    define(function(){\n      return nativePromiseSupported ? NativePromise : Promise;\n    });\n  }\n  else\n  {\n    // in browser add to global\n    if (!nativePromiseSupported)\n      global['Promise'] = Promise;\n  }\n}\n\n\n//\n// Polyfill\n//\n\nvar PENDING = 'pending';\nvar SEALED = 'sealed';\nvar FULFILLED = 'fulfilled';\nvar REJECTED = 'rejected';\nvar NOOP = function(){};\n\nfunction isArray(value) {\n  return Object.prototype.toString.call(value) === '[object Array]';\n}\n\n// async calls\nvar asyncSetTimer = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;\nvar asyncQueue = [];\nvar asyncTimer;\n\nfunction asyncFlush(){\n  // run promise callbacks\n  for (var i = 0; i < asyncQueue.length; i++)\n    asyncQueue[i][0](asyncQueue[i][1]);\n\n  // reset async asyncQueue\n  asyncQueue = [];\n  asyncTimer = false;\n}\n\nfunction asyncCall(callback, arg){\n  asyncQueue.push([callback, arg]);\n\n  if (!asyncTimer)\n  {\n    asyncTimer = true;\n    asyncSetTimer(asyncFlush, 0);\n  }\n}\n\n\nfunction invokeResolver(resolver, promise) {\n  function resolvePromise(value) {\n    resolve(promise, value);\n  }\n\n  function rejectPromise(reason) {\n    reject(promise, reason);\n  }\n\n  try {\n    resolver(resolvePromise, rejectPromise);\n  } catch(e) {\n    rejectPromise(e);\n  }\n}\n\nfunction invokeCallback(subscriber){\n  var owner = subscriber.owner;\n  var settled = owner.state_;\n  var value = owner.data_;  \n  var callback = subscriber[settled];\n  var promise = subscriber.then;\n\n  if (typeof callback === 'function')\n  {\n    settled = FULFILLED;\n    try {\n      value = callback(value);\n    } catch(e) {\n      reject(promise, e);\n    }\n  }\n\n  if (!handleThenable(promise, value))\n  {\n    if (settled === FULFILLED)\n      resolve(promise, value);\n\n    if (settled === REJECTED)\n      reject(promise, value);\n  }\n}\n\nfunction handleThenable(promise, value) {\n  var resolved;\n\n  try {\n    if (promise === value)\n      throw new TypeError('A promises callback cannot return that same promise.');\n\n    if (value && (typeof value === 'function' || typeof value === 'object'))\n    {\n      var then = value.then;  // then should be retrived only once\n\n      if (typeof then === 'function')\n      {\n        then.call(value, function(val){\n          if (!resolved)\n          {\n            resolved = true;\n\n            if (value !== val)\n              resolve(promise, val);\n            else\n              fulfill(promise, val);\n          }\n        }, function(reason){\n          if (!resolved)\n          {\n            resolved = true;\n\n            reject(promise, reason);\n          }\n        });\n\n        return true;\n      }\n    }\n  } catch (e) {\n    if (!resolved)\n      reject(promise, e);\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction resolve(promise, value){\n  if (promise === value || !handleThenable(promise, value))\n    fulfill(promise, value);\n}\n\nfunction fulfill(promise, value){\n  if (promise.state_ === PENDING)\n  {\n    promise.state_ = SEALED;\n    promise.data_ = value;\n\n    asyncCall(publishFulfillment, promise);\n  }\n}\n\nfunction reject(promise, reason){\n  if (promise.state_ === PENDING)\n  {\n    promise.state_ = SEALED;\n    promise.data_ = reason;\n\n    asyncCall(publishRejection, promise);\n  }\n}\n\nfunction publish(promise) {\n  var callbacks = promise.then_;\n  promise.then_ = undefined;\n\n  for (var i = 0; i < callbacks.length; i++) {\n    invokeCallback(callbacks[i]);\n  }\n}\n\nfunction publishFulfillment(promise){\n  promise.state_ = FULFILLED;\n  publish(promise);\n}\n\nfunction publishRejection(promise){\n  promise.state_ = REJECTED;\n  publish(promise);\n}\n\n/**\n* @class\n*/\nfunction Promise(resolver){\n  if (typeof resolver !== 'function')\n    throw new TypeError('Promise constructor takes a function argument');\n\n  if (this instanceof Promise === false)\n    throw new TypeError('Failed to construct \\'Promise\\': Please use the \\'new\\' operator, this object constructor cannot be called as a function.');\n\n  this.then_ = [];\n\n  invokeResolver(resolver, this);\n}\n\nPromise.prototype = {\n  constructor: Promise,\n\n  state_: PENDING,\n  then_: null,\n  data_: undefined,\n\n  then: function(onFulfillment, onRejection){\n    var subscriber = {\n      owner: this,\n      then: new this.constructor(NOOP),\n      fulfilled: onFulfillment,\n      rejected: onRejection\n    };\n\n    if (this.state_ === FULFILLED || this.state_ === REJECTED)\n    {\n      // already resolved, call callback async\n      asyncCall(invokeCallback, subscriber);\n    }\n    else\n    {\n      // subscribe\n      this.then_.push(subscriber);\n    }\n\n    return subscriber.then;\n  },\n\n  'catch': function(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\nPromise.all = function(promises){\n  var Class = this;\n\n  if (!isArray(promises))\n    throw new TypeError('You must pass an array to Promise.all().');\n\n  return new Class(function(resolve, reject){\n    var results = [];\n    var remaining = 0;\n\n    function resolver(index){\n      remaining++;\n      return function(value){\n        results[index] = value;\n        if (!--remaining)\n          resolve(results);\n      };\n    }\n\n    for (var i = 0, promise; i < promises.length; i++)\n    {\n      promise = promises[i];\n\n      if (promise && typeof promise.then === 'function')\n        promise.then(resolver(i), reject);\n      else\n        results[i] = promise;\n    }\n\n    if (!remaining)\n      resolve(results);\n  });\n};\n\nPromise.race = function(promises){\n  var Class = this;\n\n  if (!isArray(promises))\n    throw new TypeError('You must pass an array to Promise.race().');\n\n  return new Class(function(resolve, reject) {\n    for (var i = 0, promise; i < promises.length; i++)\n    {\n      promise = promises[i];\n\n      if (promise && typeof promise.then === 'function')\n        promise.then(resolve, reject);\n      else\n        resolve(promise);\n    }\n  });\n};\n\nPromise.resolve = function(value){\n  var Class = this;\n\n  if (value && typeof value === 'object' && value.constructor === Class)\n    return value;\n\n  return new Class(function(resolve){\n    resolve(value);\n  });\n};\n\nPromise.reject = function(reason){\n  var Class = this;\n\n  return new Class(function(resolve, reject){\n    reject(reason);\n  });\n};\n\n})(typeof window != 'undefined' ? window : typeof global != 'undefined' ? global : typeof self != 'undefined' ? self : this);\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/es6-promise-polyfill/promise.js\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/** WEBPACK FOOTER **\n ** ./~/timers-browserify/main.js\n **/","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/process/browser.js\n **/"],"sourceRoot":""}